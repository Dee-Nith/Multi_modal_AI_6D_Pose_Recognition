-- CoppeliaSim Robot Controller for Pick and Place Operations
-- Reads command files generated by Python system and executes robot movements

function sysCall_init()
    -- Initialize robot handles
    robot = sim.getObjectHandle("UR5")
    gripper = sim.getObjectHandle("RG2")
    
    -- Get robot joint handles
    joint_handles = {}
    for i = 1, 6 do
        joint_handles[i] = sim.getObjectHandle("UR5_joint" .. i)
    end
    
    -- Initialize command monitoring
    command_dir = "/tmp/robot_commands"
    last_command_file = ""
    is_executing = false
    current_commands = {}
    current_step = 1
    
    print("ü§ñ CoppeliaSim Robot Controller Initialized")
    print("üìÅ Monitoring command directory: " .. command_dir)
    print("ü§ñ Robot: UR5 with RG2 gripper")
    print("üéØ Ready to execute pick and place operations!")
end

function sysCall_actuation()
    -- Check for new command files every few simulation steps
    if sim.getSimulationTime() % 0.1 < 0.01 then
        check_for_commands()
    end
    
    -- Execute current commands if available
    if is_executing and #current_commands > 0 then
        execute_current_step()
    end
end

function check_for_commands()
    -- Look for new command files
    local files = {}
    local handle = io.popen("ls -t " .. command_dir .. "/robot_commands_*.txt 2>/dev/null")
    if handle then
        for file in handle:lines() do
            table.insert(files, file)
        end
        handle:close()
    end
    
    if #files > 0 then
        local latest_file = files[1]
        
        -- Check if this is a new command file
        if latest_file ~= last_command_file and not is_executing then
            print("üìã New command file detected: " .. latest_file)
            load_commands(latest_file)
            last_command_file = latest_file
        end
    end
end

function load_commands(filename)
    print("üìñ Loading robot commands from: " .. filename)
    
    local file = io.open(filename, "r")
    if not file then
        print("‚ùå Error: Could not open command file")
        return
    end
    
    current_commands = {}
    current_step = 1
    
    for line in file:lines() do
        line = line:gsub("^%s*(.-)%s*$", "%1") -- Trim whitespace
        
        if line ~= "" and not line:match("^#") then
            -- Parse command line
            local parts = {}
            for part in line:gmatch("%S+") do
                table.insert(parts, part)
            end
            
            if #parts > 0 then
                local command = {
                    action = parts[1],
                    params = parts
                }
                table.insert(current_commands, command)
            end
        end
    end
    
    file:close()
    
    print("‚úÖ Loaded " .. #current_commands .. " commands")
    
    -- Start execution
    if #current_commands > 0 then
        is_executing = true
        current_step = 1
        print("üöÄ Starting robot command execution...")
    end
end

function execute_current_step()
    if current_step > #current_commands then
        -- All commands completed
        print("‚úÖ All robot commands completed successfully!")
        is_executing = false
        current_commands = {}
        return
    end
    
    local command = current_commands[current_step]
    local action = command.action
    
    print("ü§ñ Executing step " .. current_step .. "/" .. #current_commands .. ": " .. action)
    
    if action == "PICK_START" then
        print("üì¶ Starting pick operation for: " .. command.params[2])
        current_step = current_step + 1
        
    elseif action == "PLACE_START" then
        print("üì¶ Starting place operation for: " .. command.params[2])
        current_step = current_step + 1
        
    elseif action == "MOVE_APPROACH" then
        local x, y, z, rx, ry, rz = tonumber(command.params[2]), tonumber(command.params[3]), 
                                   tonumber(command.params[4]), tonumber(command.params[5]), 
                                   tonumber(command.params[6]), tonumber(command.params[7])
        move_robot_to_position(x, y, z, rx, ry, rz, "approach position")
        
    elseif action == "MOVE_PICK" then
        local x, y, z, rx, ry, rz = tonumber(command.params[2]), tonumber(command.params[3]), 
                                   tonumber(command.params[4]), tonumber(command.params[5]), 
                                   tonumber(command.params[6]), tonumber(command.params[7])
        move_robot_to_position(x, y, z, rx, ry, rz, "pick position")
        
    elseif action == "MOVE_LIFT" then
        local x, y, z, rx, ry, rz = tonumber(command.params[2]), tonumber(command.params[3]), 
                                   tonumber(command.params[4]), tonumber(command.params[5]), 
                                   tonumber(command.params[6]), tonumber(command.params[7])
        move_robot_to_position(x, y, z, rx, ry, rz, "lift position")
        
    elseif action == "MOVE_PLACE_APPROACH" then
        local x, y, z, rx, ry, rz = tonumber(command.params[2]), tonumber(command.params[3]), 
                                   tonumber(command.params[4]), tonumber(command.params[5]), 
                                   tonumber(command.params[6]), tonumber(command.params[7])
        move_robot_to_position(x, y, z, rx, ry, rz, "place approach position")
        
    elseif action == "MOVE_PLACE" then
        local x, y, z, rx, ry, rz = tonumber(command.params[2]), tonumber(command.params[3]), 
                                   tonumber(command.params[4]), tonumber(command.params[5]), 
                                   tonumber(command.params[6]), tonumber(command.params[7])
        move_robot_to_position(x, y, z, rx, ry, rz, "place position")
        
    elseif action == "GRIPPER_OPEN" then
        open_gripper()
        
    elseif action == "GRIPPER_CLOSE" then
        close_gripper()
        
    elseif action == "PICK_END" then
        print("‚úÖ Pick operation completed for: " .. command.params[2])
        current_step = current_step + 1
        
    elseif action == "PLACE_END" then
        print("‚úÖ Place operation completed for: " .. command.params[2])
        current_step = current_step + 1
        
    elseif action == "RETURN_HOME" then
        local x, y, z, rx, ry, rz = tonumber(command.params[2]), tonumber(command.params[3]), 
                                   tonumber(command.params[4]), tonumber(command.params[5]), 
                                   tonumber(command.params[6]), tonumber(command.params[7])
        move_robot_to_position(x, y, z, rx, ry, rz, "home position")
        
    elseif action == "SYSTEM_READY" then
        print("üèÅ System ready for next operation")
        current_step = current_step + 1
        
    else
        print("‚ö†Ô∏è Unknown command: " .. action)
        current_step = current_step + 1
    end
end

function move_robot_to_position(x, y, z, rx, ry, rz, description)
    print("ü§ñ Moving robot to " .. description .. ": (" .. x .. ", " .. y .. ", " .. z .. ")")
    
    -- Convert world coordinates to robot joint angles (simplified)
    -- In a real implementation, you'd use inverse kinematics
    local target_joints = calculate_joint_angles(x, y, z, rx, ry, rz)
    
    if target_joints then
        -- Move robot to target joint configuration
        for i = 1, 6 do
            sim.setJointTargetPosition(joint_handles[i], target_joints[i])
        end
        
        -- Wait for movement to complete (simplified)
        sim.wait(2) -- Wait 2 seconds for movement
        
        print("‚úÖ Robot moved to " .. description)
    else
        print("‚ùå Failed to calculate joint angles for " .. description)
    end
    
    current_step = current_step + 1
end

function calculate_joint_angles(x, y, z, rx, ry, rz)
    -- Simplified joint angle calculation
    -- In a real implementation, you'd use proper inverse kinematics
    
    -- For now, use approximate joint angles based on position
    local base_angle = math.atan2(y, x)
    local reach = math.sqrt(x*x + y*y)
    local height = z
    
    -- Simplified 6-DOF UR5 joint angles
    local joints = {
        base_angle,                    -- Base rotation
        -math.pi/4,                    -- Shoulder
        -math.pi/2,                    -- Elbow
        0,                             -- Wrist 1
        -math.pi/2,                    -- Wrist 2
        0                              -- Wrist 3
    }
    
    return joints
end

function open_gripper()
    print("ü§è Opening gripper...")
    sim.setIntProperty(sim.handle_scene, 'signal.RG2_open', 1)
    sim.wait(1) -- Wait for gripper to open
    print("‚úÖ Gripper opened")
    current_step = current_step + 1
end

function close_gripper()
    print("ü§è Closing gripper...")
    sim.setIntProperty(sim.handle_scene, 'signal.RG2_open', 0)
    sim.wait(1) -- Wait for gripper to close
    print("‚úÖ Gripper closed")
    current_step = current_step + 1
end

function sysCall_cleanup()
    print("üèÅ Robot Controller Cleanup Complete")
end




